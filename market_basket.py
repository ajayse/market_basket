# -*- coding: utf-8 -*-
"""goparts_marketBasket.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Cv03gEYt2M4P2Y07tsegUZEM2Odgg7aX

**To do**
---

Optimize rules - support, confidence, lift \\
Visualize result - how? best? \\
More than1 antecedent \\
association of group of products \\
Application - marketing, supply and logistics, website experience \\
reporting \\
more general items (product categories, sku only)

**Install and import packages**
---
Pandas \\
Numpy \\
Pyplot \\
Seaborn \\
Apriori \\
Plotly \\
Networkx \\
"""

import pandas as pd
from mlxtend.frequent_patterns import association_rules, apriori
import networkx as nx
import plotly.graph_objects as go
import plotly
import math
from itertools import cycle
import streamlit as st

st.set_page_config(layout="wide",
                    page_title='Market Basket Analysis',
                    page_icon=":convenience_store:",
                    initial_sidebar_state='expanded',
                    menu_items = {
                         'About':"# Thanks for using the app!\n For inquiries, send an email to Arvin Escolano at arvinjayescolano.licagroup@gmail.com."
                        })


st.title("""**Market Basket Analysis**""")

def find_rules(df_temp, transaction_id, segmentation, min_s = 10, disp = False,quantity = 'quantity'):
  df_basket = pd.DataFrame()
  df_basket = df_temp[[transaction_id, segmentation, quantity]].copy()
  df_basket_items = df_basket.groupby([transaction_id,segmentation])[quantity].sum().unstack(1).reset_index().set_index(transaction_id)
  basket_items = (df_basket_items.notnull()).astype('bool')
  frequent_itemsets = apriori(basket_items, min_support= min_s/100, use_colnames=True, max_len = 5)
  rules = association_rules(frequent_itemsets, metric="leverage",  min_threshold = 0)
  rules["antecedents"] = rules["antecedents"].apply(lambda x: ', '.join(list(x))).astype("unicode")
  rules["consequents"] = rules["consequents"].apply(lambda x: ', '.join(list(x))).astype("unicode")
  rules['hover_name'] = rules['antecedents'] +"\u2192" + rules['consequents']
  rules["antecedent"] = rules["antecedents"].copy()
  return df_basket_items, rules

def bar_hist(df_test, seg, prob, cat = 'id'):

  fig = go.Figure()
  total_count = df_test.groupby(cat)[seg].count().sum()
  if prob:
    title_text = "Probability"
    df = df_test.groupby(seg)[cat].apply(lambda x:100* x.count()/total_count).sort_values(ascending =False)
  else:
    title_text = "Actual Order Count"
    df = df_test.groupby(seg)[seg].apply(lambda x: x.count()).sort_values(ascending =False)
  fig.add_trace(
    go.Bar(x=df.index,
          y=df,
          visible = True,
          text =df.index,
          textposition = 'outside'))
  seg = segment_dict[seg]
  fig.update_layout(template = 'simple_white',title_text= title_text+" of "+seg+"s Being Bought per Basket",bargap=0.05, width = 1000, height = 500)
  if prob:
    ya_text = 'Probability (%)'
  else:
    ya_text = 'Count (units)'
  fig.update_yaxes(title_text = ya_text,showline=True, linewidth=1, linecolor='black', mirror=True, ticks ='inside',range = [0,df.max()*1.1])
  fig.update_xaxes(title_text = seg,showline=True, linewidth=1, linecolor='black', ticks ='',mirror=True,range = [-0.5,9.5], rangeslider=dict(visible=True),showticklabels=False)
  st.plotly_chart(fig)



def hist(df_test, is_prob = True, is_count = True, step = 1):
  df_data=pd.DataFrame()
  df_test = df_test[['id','quantity','cost']].copy()
  total_count = df_test['id'].nunique()
  if is_count:
    df_data['quantity'] = df_test.groupby('id')['quantity'].sum().apply(lambda x: math.ceil(x/step)*step)
    df = df_data.groupby('quantity')['quantity'].count()
    t_text = "Market Basket Item Count"
    x_title = "Basket Item Count"
  else:
    df_data['cost'] = df_test.groupby('id')['cost'].sum().apply(lambda x: math.ceil(x/step)*step)
    df = df_data.groupby('cost')['cost'].count()
    t_text = "Market Basket Price"
    x_title = "Basket Price"

  fig = go.Figure()
  if is_prob:
    title_text = "Probability"
    df = round(100 * df/total_count,2)
    suff = "%"
    ya_text = 'Probability (%)'
  else:
    title_text = "Actual Order Count"
    suff = ""
    ya_text = 'Count (# of baskets)'
  fig.add_trace(
    go.Bar(x=df.index,
          y=df,
          visible = True,
          text = df.apply(lambda x: str(x)+suff),
          textposition = 'outside'))
  fig.update_layout(template = 'simple_white',title_text= t_text + "("+ title_text+")" ,bargap=0.05)
  fig.update_yaxes(title_text = ya_text,showline=True, linewidth=1, linecolor='black', mirror=True, range = [0,df.max()*1.1] )#autorange = True
  fig.update_xaxes(title_text = x_title,showline=True, linewidth=1, linecolor='black', mirror=True,range = [0.5*step,(10.5)*step], rangeslider=dict(visible=True),showticklabels=True)
  st.plotly_chart(fig)

def df_to_plotly(df):
    return {'z': df.values.tolist(),
            'x': df.columns.tolist(),
            'y': df.index.tolist()}
def heatmap_ac(rulesAll):
  df_heatmap = rulesAll.groupby(['antecedents', 'consequents'])['support'].apply(lambda x: round(x.unique().item()*100,2)).fillna(0).unstack(1).reset_index().set_index('antecedents')
  df_heatmap_ = rulesAll.groupby(['antecedents', 'consequents'])['support'].apply(lambda x: round(x.unique().item()*100,2)).fillna(0).unstack(1).reset_index().set_index('antecedents')
  df__ = df_to_plotly(df_heatmap)

  fig = go.Figure()
  fig.add_trace(go.Heatmap(df__,
                  text = df_heatmap_.fillna("0"),
                  texttemplate="%{text}",
                  hoverongaps = False,
                  ))
  fig.update_xaxes(title_text = 'consequent',tickson='boundaries',showline=True, linewidth=1, linecolor='black', mirror=True, ticks='', showgrid=True)
  fig.update_yaxes(title_text = 'antecedent',tickson='boundaries',showline=True, linewidth=1, linecolor='black', mirror=True, ticks='', showgrid=True,autorange='reversed')
  fig.update_layout(template='simple_white', title_text = "Correlation Heatmap between Antecedents and Consequents", width = 1150, height = 700)
  st.plotly_chart(fig)

def xy_scatter(df_temp,segment, item_x,item_y, set_vis=True):
  df_temp = df_temp.set_index('hover_name')
  colors = cycle(plotly.colors.sequential.Viridis)
  fig = go.Figure()
  for seg in df_temp[segment].unique():
    fig.add_trace(
        go.Scatter(
            x = df_temp.loc[df_temp[segment]== seg][item_x],
            y = df_temp.loc[df_temp[segment]== seg][item_y],
            mode = 'markers',
            marker = dict(
                size = df_temp['lift']/df_temp['lift'].max()*30,
                color = df_temp['lift']
            ),
            visible = set_vis,
            name = seg,
            marker_color =next(colors),
            hovertemplate = list(df_temp.loc[df_temp[segment]== seg].index)
        )
    )
  fig.update_layout(legend=dict(
      yanchor="top",
      y=0.99,
      xanchor="left",
      x=1.01,
      title = segment
  ))

  fig.update_layout(template = 'simple_white',title_text= item_y+" vs. "+item_x)
  fig.update_yaxes(title_text = item_y+" (%)",showline=True, linewidth=1, linecolor='black', mirror=True, ticks = 'inside')
  fig.update_xaxes(title_text = item_x+" (%)",showline=True, linewidth=1, linecolor='black', mirror=True, ticks = 'inside')
  st.plotly_chart(fig)

def basket_network_plot(rules, plot_title = 'Insert Plot Title', clean = False):
  G=nx.from_pandas_edgelist(rules,source='antecedents',target='consequents', edge_attr=True)
  pos = nx.drawing.layout.spring_layout(G)
  nx.set_node_attributes(G, pos, 'pos')

  if clean:
    mode_plot = 'markers'
  else:
    mode_plot = 'markers+text'

  edge_x = []
  edge_y = []
  for edge in G.edges():
      x0, y0 = G.nodes[edge[0]]['pos']
      x1, y1 = G.nodes[edge[1]]['pos']
      edge_x.append(x0)
      edge_x.append(x1)
      edge_x.append(None)
      edge_y.append(y0)
      edge_y.append(y1)
      edge_y.append(None)

  edge_trace = go.Scatter(
      x=edge_x, y=edge_y,
      line=dict(width=1, color='#888'),
      hoverinfo='none',
      mode='lines')

  node_x = []
  node_y = []
  for node in G.nodes():
      x, y = G.nodes[node]['pos']
      node_x.append(x)
      node_y.append(y)

  node_trace = go.Scatter(
      x=node_x, y=node_y,
      mode=mode_plot,
      text = node_x,
      textposition = 'bottom center',
      hoverinfo='text',
      marker=dict(
          showscale=True,
          colorscale='YlGnBu',
          reversescale=True,
          color=[],
          size=25,
          opacity = 1,
          colorbar=dict(
              thickness=10,
              title='Lift',
              xanchor='left',
              titleside='right'
          ),
          line_width=2))

  node_adjacencies = []
  node_text = []
  node_size = []
  see = []
  for node, adjacencies in enumerate(G.adjacency()):
      confidence = round(pd.DataFrame.from_dict(adjacencies[1]).iloc[:,0].loc['confidence']*100,2)
      lift = round(pd.DataFrame.from_dict(adjacencies[1]).iloc[:,0].loc['lift']*100,2)
      n_adjacencies = len(adjacencies[1])
      node_adjacencies.append(lift)
      if n_adjacencies != 1:
        node_text.append(str(adjacencies[0])+' (Support='+str(round(pd.DataFrame.from_dict(adjacencies[1]).iloc[:,0].loc['antecedent support']*100,2)) + '%)')#('['+str(n_adjacencies)+'] '+str(adjacencies[0])+': '+str(c_support) + '%')
      else:
        node_text.append(str(adjacencies[0])+' (Confidence: '+str(confidence) + '%)')
      node_size.append(n_adjacencies)
      see.append(adjacencies)

  node_trace.marker.color = node_adjacencies
  node_trace.text = node_text
  node_trace.marker.size = 15#[(x/max(node_size))*25 for x in node_size]

  fig = go.Figure(data=[edge_trace, node_trace], #text = 'a',
              layout=go.Layout(template = 'simple_white',
                  title= plot_title,
                  titlefont_size=18,
                  showlegend=False,
                  hovermode='closest',
                  margin=dict(b=20,l=5,r=5,t=40),
                  xaxis=dict(showgrid=False, zeroline=False, showticklabels=False,showline=True, linewidth=1, linecolor='black', mirror=True,ticks = '', range =[-1.25,1.25]),
                  yaxis=dict(showgrid=False, zeroline=False, showticklabels=False,showline=True, linewidth=1, linecolor='black', mirror=True,ticks = '', range =[-1.25,1.25]))
                  )
  st.plotly_chart(fig)

@st.experimental_memo()
def gather_data():
    df_raw = pd.read_csv("http://app.redash.licagroup.ph/api/queries/118/results.csv?api_key=nVfPq3pxbOF6uSWOlCI8HQSRmgMb34OD6tWvrapY", parse_dates = ['created_at'])
    df_raw = df_raw.loc[df_raw['quantity']>0]
    df_raw = df_raw.loc[:,['id', 'GarageId','product_desc', 'garage_type', 'brand', 'category_name','quantity','price']]
    df_raw = df_raw.loc[df_raw['price']>0]
    df_raw['brand_category'] = [str(x) + ' '+str(y).title() for (x,y) in zip(df_raw['brand'], df_raw['category_name'])]
    df_raw['cost'] = df_raw['quantity']*df_raw['price']
    df_raw = df_raw.dropna()
    df_raw.category_name.sort_values().unique()
    return df_raw

df_raw = gather_data()
segments = ['Brand','Category','Category_Brand','SKU']
segments_ = ['product_desc','brand','category_name','brand_category']
segment_dict = {'product_desc':'SKU',
                'brand':'Brand',
                'category_name':'Category',
                'brand_category':'Category_Brand'}
segment_dict_ = {v: k for k, v in segment_dict.items()}

st.header('Data Exploration')
cA, cB = st.columns([1,3])
with cA:
    st.header("Controls")
    seg = st.selectbox('Select Segmentation', segments)
    is_prob = st.radio("Data presentation: ", ('Probability','Actual Count'),  horizontal=True)
    count_step = st.number_input('Step for basket count:', 1, 100, 1)
    price_step = st.number_input('Step for basket price:', 100, 10000, 1000)
    garage_type = st.selectbox(
        label = 'Select considered garages:',
        options =('All','Rapide', 'Non-Rapide', 'Non-B2C', 'B2C'))
    if garage_type =='Non-Rapide':
      df_raw = df_raw.loc[df_raw['garage_type'] != 'rapide_service_center' ]
    elif garage_type == 'Rapide':
      df_raw = df_raw.loc[df_raw['garage_type'] == 'rapide_service_center' ]
    elif garage_type == 'Non-B2C':
      df_raw = df_raw.loc[~df_raw['garage_type'].isin(['rapide_service_center','Inactive'])]
    elif garage_type == 'B2C':
      df_raw = df_raw.loc[df_raw['garage_type']== 'Inactive']
    if st.button("Reset Data"):
        st.experimental_memo.clear()
        df_raw = pd.DataFrame()
with cB:
    bar_hist(df_raw,segment_dict_[seg], is_prob=='Probability','id')
    
cD, cE = st.columns([1,1])
with cD:
    hist(df_raw, is_prob=='Probability', True,step = count_step)
with cE:
    hist(df_raw, is_prob=='Probability', False,step = price_step)

cF, cG= st.columns([1,5])
with cF:
    segmentation = st.selectbox('Select Segmentation:', segments)
    s_segmentation = segment_dict_[segmentation]
    clean = st.checkbox('Clean network plot ', value=False)

itemsAll, rulesAll = find_rules(df_raw, 'id', s_segmentation, 2) 
selection = rulesAll.columns   
with cG:
    heatmap_ac(rulesAll)

set_vis = True
segment = 'antecedent'
cI, cJ = st.columns([1,1])
with cI:
    item_y = st.selectbox('y-axis', selection, index = 5)
    item_x = st.selectbox('x-axis', selection, index = 4)
    xy_scatter(rulesAll,segment, item_x,item_y, set_vis)
with cJ:
    filter_network = rulesAll['antecedents'].unique()
    s_filter = item_x = st.selectbox('x-axis', filter_network, index = 0)
    basket_network_plot(rulesAll.loc[rulesAll['antecedents']==s_filter], 'Category Association',clean) #.str.contains('NGK',na=False)
cK, cL, cM = st.columns([3,5,3])
with cL:
    basket_network_plot(rulesAll, 'Product Associations', clean)
